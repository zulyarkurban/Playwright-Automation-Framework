import { stripVTControlCharacters } from 'node:util';
import { AttachmentContentEncoding, TestStepResultStatus, } from '@cucumber/messages';
import { TextBuilder } from './TextBuilder.js';
export const GHERKIN_INDENT_LENGTH = 2;
export const STEP_ARGUMENT_INDENT_LENGTH = 2;
export const ATTACHMENT_INDENT_LENGTH = 4;
export const ERROR_INDENT_LENGTH = 4;
export function ensure(value, message) {
    if (!value) {
        throw new Error(message);
    }
    return value;
}
export function indent(original, by) {
    return original
        .split('\n')
        .map((line) => ' '.repeat(by) + line)
        .join('\n');
}
export function pad(original) {
    return `\n` + original + '\n';
}
export function unstyled(text) {
    return stripVTControlCharacters(text);
}
export function formatFeatureTitle(feature, theme, stream) {
    return new TextBuilder(stream)
        .append(feature.keyword + ':', theme.feature?.keyword)
        .space()
        .append(feature.name, theme.feature?.name)
        .build(theme.feature?.all);
}
export function formatRuleTitle(rule, theme, stream) {
    return new TextBuilder(stream)
        .append(rule.keyword + ':', theme.rule?.keyword)
        .space()
        .append(rule.name, theme.rule?.name)
        .build(theme.rule?.all);
}
export function formatPickleTags(pickle, theme, stream) {
    if (pickle && pickle.tags.length > 0) {
        return new TextBuilder(stream)
            .append(pickle.tags.map((tag) => `${tag.name}`).join(' '))
            .build(theme.tag);
    }
}
export function formatPickleTitle(pickle, scenario, theme, stream) {
    return new TextBuilder(stream)
        .append(scenario.keyword + ':', theme.scenario?.keyword)
        .space()
        .append(pickle.name || '', theme.scenario?.name)
        .build(theme.scenario?.all);
}
export function formatPickleLocation(pickle, location, theme, stream) {
    const builder = new TextBuilder(stream).append('#').space().append(pickle.uri);
    if (location) {
        builder.append(':').append(location.line);
    }
    return builder.build(theme.location);
}
export function formatStepTitle(testStep, pickleStep, step, status, theme, stream) {
    const builder = new TextBuilder(stream);
    if (theme.status?.icon?.[status]) {
        builder.append(theme.status.icon[status], theme.status?.all?.[status]).space();
    }
    return builder
        .append(new TextBuilder(stream)
        .append(step.keyword, theme.step?.keyword)
        // step keyword includes a trailing space
        .append(formatStepText(testStep, pickleStep, theme, stream))
        .build(theme.status?.all?.[status]))
        .build();
}
function formatStepText(testStep, pickleStep, theme, stream) {
    const builder = new TextBuilder(stream);
    const stepMatchArgumentsLists = testStep.stepMatchArgumentsLists;
    if (stepMatchArgumentsLists && stepMatchArgumentsLists.length === 1) {
        const stepMatchArguments = stepMatchArgumentsLists[0].stepMatchArguments;
        let offset = 0;
        let plain;
        stepMatchArguments.forEach((argument) => {
            plain = pickleStep.text.slice(offset, argument.group.start);
            builder.append(plain, theme.step?.text);
            const arg = argument.group.value;
            if (arg) {
                if (arg.length > 0) {
                    builder.append(arg, theme.step?.argument);
                }
                offset += plain.length + arg.length;
            }
        });
        plain = pickleStep.text.slice(offset);
        if (plain.length > 0) {
            builder.append(plain, theme.step?.text);
        }
    }
    else {
        builder.append(pickleStep.text, theme.step?.text);
    }
    return builder.build();
}
export function formatStepLocation(stepDefinition, theme, stream) {
    if (stepDefinition?.sourceReference.uri) {
        const builder = new TextBuilder(stream)
            .append('#')
            .space()
            .append(stepDefinition.sourceReference.uri);
        if (stepDefinition.sourceReference.location) {
            builder.append(':').append(stepDefinition.sourceReference.location.line);
        }
        return builder.build(theme.location);
    }
}
export function formatStepArgument(pickleStep, theme, stream) {
    if (pickleStep.argument?.docString) {
        return formatDocString(pickleStep.argument.docString, theme, stream);
    }
    if (pickleStep.argument?.dataTable) {
        return formatDataTable(pickleStep.argument.dataTable, theme, stream);
    }
}
function formatDocString(docString, theme, stream) {
    const builder = new TextBuilder(stream).append('"""', theme.docString?.delimiter);
    if (docString.mediaType) {
        builder.append(docString.mediaType, theme.docString?.mediaType);
    }
    builder
        .line()
        .append(docString.content, theme.docString?.content)
        .line()
        .append('"""', theme.docString?.delimiter);
    return builder.build(theme.docString?.all, true);
}
function formatDataTable(dataTable, theme, stream) {
    const columnWidths = calculateColumnWidths(dataTable);
    const builder = new TextBuilder(stream);
    dataTable.rows.forEach((row, rowIndex) => {
        if (rowIndex > 0) {
            builder.line();
        }
        builder.append('|', theme.dataTable?.border);
        row.cells.forEach((cell, cellIndex) => {
            builder
                .append(' ' + cell.value.padEnd(columnWidths[cellIndex]) + ' ', theme.dataTable?.content)
                .append('|', theme.dataTable?.border);
        });
    });
    return builder.build(theme.dataTable?.all, true);
}
function calculateColumnWidths(dataTable) {
    const columnWidths = [];
    for (const row of dataTable.rows) {
        for (let i = 0; i < row.cells.length; i++) {
            const cellWidth = row.cells[i].value.length;
            if (columnWidths[i] === undefined || cellWidth > columnWidths[i]) {
                columnWidths[i] = cellWidth;
            }
        }
    }
    return columnWidths;
}
export function formatTestStepResultError(testStepResult, theme, stream) {
    if (testStepResult.exception?.stackTrace) {
        return new TextBuilder(stream)
            .append(testStepResult.exception.stackTrace.trim())
            .build(theme.status?.all?.[testStepResult.status], true);
    }
    // Fallback
    if (testStepResult?.exception?.message) {
        return new TextBuilder(stream)
            .append(testStepResult.exception.message.trim())
            .build(theme.status?.all?.[testStepResult.status], true);
    }
    // Fallback
    if (testStepResult?.message) {
        return new TextBuilder(stream)
            .append(testStepResult.message.trim())
            .build(theme.status?.all?.[testStepResult.status], true);
    }
}
export function formatTestRunFinishedError(testRunFinished, theme, stream) {
    if (testRunFinished.exception?.stackTrace) {
        return new TextBuilder(stream)
            .append(testRunFinished.exception.stackTrace.trim())
            .build(theme.status?.all?.[TestStepResultStatus.FAILED], true);
    }
    // Fallback
    if (testRunFinished?.exception?.message) {
        return new TextBuilder(stream)
            .append(testRunFinished.exception.message.trim())
            .build(theme.status?.all?.[TestStepResultStatus.FAILED], true);
    }
}
export function formatAttachment(attachment, theme, stream) {
    switch (attachment.contentEncoding) {
        case AttachmentContentEncoding.BASE64:
            return formatBase64Attachment(attachment.body, attachment.mediaType, attachment.fileName, theme, stream);
        case AttachmentContentEncoding.IDENTITY:
            return formatTextAttachment(attachment.body, theme, stream);
    }
}
function formatBase64Attachment(data, mediaType, fileName, theme, stream) {
    const builder = new TextBuilder(stream);
    const bytes = (data.length / 4) * 3;
    if (fileName) {
        builder.append(`Embedding ${fileName} [${mediaType} ${bytes} bytes]`);
    }
    else {
        builder.append(`Embedding [${mediaType} ${bytes} bytes]`);
    }
    return builder.build(theme.attachment);
}
function formatTextAttachment(content, theme, stream) {
    return new TextBuilder(stream).append(content).build(theme.attachment);
}
//# sourceMappingURL=helpers.js.map