import { TestStepResultStatus, } from '@cucumber/messages';
import { Query } from '@cucumber/query';
import { ATTACHMENT_INDENT_LENGTH, ensure, ERROR_INDENT_LENGTH, formatAttachment, formatFeatureTitle, formatPickleLocation, formatPickleTags, formatPickleTitle, formatRuleTitle, formatStepArgument, formatStepLocation, formatStepTitle, formatTestRunFinishedError, formatTestStepResultError, GHERKIN_INDENT_LENGTH, indent, pad, STEP_ARGUMENT_INDENT_LENGTH, unstyled, } from './helpers.js';
export class PrettyPrinter {
    stream;
    print;
    options;
    println;
    query = new Query();
    scenarioIndentByTestCaseStartedId = new Map();
    maxContentLengthByTestCaseStartedId = new Map();
    encounteredFeaturesAndRules = new Set();
    constructor(stream, print, options) {
        this.stream = stream;
        this.print = print;
        this.options = options;
        this.println = (content = '') => this.print(`${content}\n`);
    }
    update(message) {
        this.query.update(message);
        if (message.testCaseStarted) {
            this.preCalculateIndentAndMaxContentLength(message.testCaseStarted);
            this.handleTestCaseStarted(message.testCaseStarted);
        }
        if (message.attachment) {
            this.handleAttachment(message.attachment);
        }
        if (message.testStepFinished) {
            this.handleTestStepFinished(message.testStepFinished);
        }
        if (message.testRunFinished) {
            this.handleTestRunFinished(message.testRunFinished);
        }
    }
    resolveScenario(testCaseStarted) {
        const pickle = ensure(this.query.findPickleBy(testCaseStarted), 'Pickle must exist for TestCaseStarted');
        const location = this.query.findLocationOf(pickle);
        const lineage = ensure(this.query.findLineageBy(pickle), 'Lineage must exist for Pickle');
        const scenario = ensure(lineage.scenario, 'Scenario must exist for Lineage');
        const rule = lineage.rule;
        const feature = ensure(lineage.feature, 'Feature must exist for Lineage');
        return {
            pickle,
            location,
            scenario,
            rule,
            feature,
        };
    }
    resolveStep(testStepFinished) {
        const testStep = ensure(this.query.findTestStepBy(testStepFinished), 'TestStep must exist for TestStepFinished');
        const pickleStep = this.query.findPickleStepBy(testStep);
        if (!pickleStep) {
            return undefined;
        }
        const step = ensure(this.query.findStepBy(pickleStep), 'Step must exist for PickleStep');
        const stepDefinition = this.query.findUnambiguousStepDefinitionBy(testStep);
        return {
            testStep,
            pickleStep,
            step,
            stepDefinition,
        };
    }
    preCalculateIndentAndMaxContentLength(testCaseStarted) {
        const pickle = ensure(this.query.findPickleBy(testCaseStarted), 'Pickle must exist for TestCaseStarted');
        const lineage = ensure(this.query.findLineageBy(pickle), 'Lineage must exist for Pickle');
        const scenario = ensure(lineage.scenario, 'Scenario must exist for Lineage');
        const scenarioLength = unstyled(formatPickleTitle(pickle, scenario, this.options.theme, this.stream)).length;
        const testCase = ensure(this.query.findTestCaseBy(testCaseStarted), 'TestCase must exist for TestCaseStarted');
        const stepLengths = testCase.testSteps
            .filter((testStep) => !!testStep.pickleStepId)
            .map((testStep) => {
            const pickleStep = ensure(this.query.findPickleStepBy(testStep), 'PickleStep must exist for TestStep');
            const step = ensure(this.query.findStepBy(pickleStep), 'Step must exist for PickleStep');
            return indent(unstyled(formatStepTitle(testStep, pickleStep, step, TestStepResultStatus.UNKNOWN, this.options.theme, this.stream)), GHERKIN_INDENT_LENGTH).length;
        });
        this.maxContentLengthByTestCaseStartedId.set(testCaseStarted.id, Math.max(scenarioLength, ...stepLengths));
        let scenarioIndent = 0;
        if (this.options.featuresAndRules) {
            scenarioIndent += GHERKIN_INDENT_LENGTH;
            if (lineage.rule) {
                scenarioIndent += GHERKIN_INDENT_LENGTH;
            }
        }
        this.scenarioIndentByTestCaseStartedId.set(testCaseStarted.id, scenarioIndent);
    }
    getScenarioIndentBy(by) {
        if ('testCaseStartedId' in by && by.testCaseStartedId) {
            return this.scenarioIndentByTestCaseStartedId.get(by.testCaseStartedId) ?? 0;
        }
        else if ('testCaseId' in by) {
            return this.scenarioIndentByTestCaseStartedId.get(by.id) ?? 0;
        }
        return 0;
    }
    getMaxContentLengthBy(by) {
        if ('testCaseStartedId' in by) {
            return this.maxContentLengthByTestCaseStartedId.get(by.testCaseStartedId) ?? 0;
        }
        return this.maxContentLengthByTestCaseStartedId.get(by.id) ?? 0;
    }
    handleTestCaseStarted(testCaseStarted) {
        const { pickle, location, scenario, rule, feature } = this.resolveScenario(testCaseStarted);
        const scenarioIndent = this.getScenarioIndentBy(testCaseStarted);
        const maxContentLength = this.getMaxContentLengthBy(testCaseStarted);
        this.printFeatureLine(feature);
        this.printRuleLine(rule);
        this.println();
        this.printTags(pickle, scenarioIndent);
        this.printScenarioLine(pickle, scenario, location, scenarioIndent, maxContentLength);
    }
    printFeatureLine(feature) {
        if (this.options.featuresAndRules && !this.encounteredFeaturesAndRules.has(feature)) {
            this.println();
            this.println(formatFeatureTitle(feature, this.options.theme, this.stream));
        }
        this.encounteredFeaturesAndRules.add(feature);
    }
    printRuleLine(rule) {
        if (rule) {
            if (this.options.featuresAndRules && !this.encounteredFeaturesAndRules.has(rule)) {
                this.println();
                this.println(indent(formatRuleTitle(rule, this.options.theme, this.stream), GHERKIN_INDENT_LENGTH));
            }
            this.encounteredFeaturesAndRules.add(rule);
        }
    }
    printTags(pickle, scenarioIndent) {
        const output = formatPickleTags(pickle, this.options.theme, this.stream);
        if (output) {
            this.println(indent(output, scenarioIndent));
        }
    }
    printScenarioLine(pickle, scenario, location, scenarioIndent, maxContentLength) {
        this.printGherkinLine(formatPickleTitle(pickle, scenario, this.options.theme, this.stream), formatPickleLocation(pickle, location, this.options.theme, this.stream), scenarioIndent, maxContentLength);
    }
    handleTestStepFinished(testStepFinished) {
        const scenarioIndent = this.getScenarioIndentBy(testStepFinished);
        const maxContentLength = this.getMaxContentLengthBy(testStepFinished);
        const resolved = this.resolveStep(testStepFinished);
        if (resolved) {
            const { testStep, pickleStep, step, stepDefinition } = resolved;
            this.printStepLine(testStepFinished, testStep, pickleStep, step, stepDefinition, scenarioIndent, maxContentLength);
            this.printStepArgument(pickleStep, scenarioIndent);
        }
        this.printError(testStepFinished, scenarioIndent);
    }
    printStepLine(testStepFinished, testStep, pickleStep, step, stepDefinition, scenarioIndent, maxContentLength) {
        this.printGherkinLine(indent(formatStepTitle(testStep, pickleStep, step, testStepFinished.testStepResult.status, this.options.theme, this.stream), GHERKIN_INDENT_LENGTH), formatStepLocation(stepDefinition, this.options.theme, this.stream), scenarioIndent, maxContentLength);
    }
    printStepArgument(pickleStep, scenarioIndent) {
        const content = formatStepArgument(pickleStep, this.options.theme, this.stream);
        if (content) {
            this.println(indent(content, scenarioIndent +
                (this.options.theme.status?.icon ? GHERKIN_INDENT_LENGTH : 0) +
                GHERKIN_INDENT_LENGTH +
                STEP_ARGUMENT_INDENT_LENGTH));
        }
    }
    printGherkinLine(title, location, indentBy, maxContentLength) {
        let output = title;
        if (location) {
            const padding = maxContentLength - unstyled(title).length;
            output += indent(location, padding + 1);
        }
        this.println(indent(output, indentBy));
    }
    printError(testStepFinished, scenarioIndent) {
        const content = formatTestStepResultError(testStepFinished.testStepResult, this.options.theme, this.stream);
        if (content) {
            this.println(indent(content, scenarioIndent +
                (this.options.theme.status?.icon ? GHERKIN_INDENT_LENGTH : 0) +
                GHERKIN_INDENT_LENGTH +
                ERROR_INDENT_LENGTH));
        }
    }
    handleAttachment(attachment) {
        if (!this.options.attachments) {
            return;
        }
        const scenarioIndent = this.getScenarioIndentBy(attachment);
        const content = formatAttachment(attachment, this.options.theme, this.stream);
        this.println(pad(indent(content, scenarioIndent +
            (this.options.theme.status?.icon ? GHERKIN_INDENT_LENGTH : 0) +
            GHERKIN_INDENT_LENGTH +
            ATTACHMENT_INDENT_LENGTH)));
    }
    handleTestRunFinished(testRunFinished) {
        const content = formatTestRunFinishedError(testRunFinished, this.options.theme, this.stream);
        if (content) {
            this.println(content);
        }
    }
}
//# sourceMappingURL=PrettyPrinter.js.map